module Dodopayments
  module Models
    type price =
      Dodopayments::Price::OneTimePrice
      | Dodopayments::Price::RecurringPrice
      | Dodopayments::Price::UsageBasedPrice

    module Price
      extend Dodopayments::Internal::Type::Union

      type one_time_price =
        {
          currency: Dodopayments::Models::currency,
          discount: Integer,
          price: Integer,
          purchasing_power_parity: bool,
          type: Dodopayments::Models::Price::OneTimePrice::type_,
          pay_what_you_want: bool,
          suggested_price: Integer?,
          tax_inclusive: bool?
        }

      class OneTimePrice < Dodopayments::Internal::Type::BaseModel
        attr_accessor currency: Dodopayments::Models::currency

        attr_accessor discount: Integer

        attr_accessor price: Integer

        attr_accessor purchasing_power_parity: bool

        attr_accessor type: Dodopayments::Models::Price::OneTimePrice::type_

        attr_reader pay_what_you_want: bool?

        def pay_what_you_want=: (bool) -> bool

        attr_accessor suggested_price: Integer?

        attr_accessor tax_inclusive: bool?

        def initialize: (
          currency: Dodopayments::Models::currency,
          discount: Integer,
          price: Integer,
          purchasing_power_parity: bool,
          type: Dodopayments::Models::Price::OneTimePrice::type_,
          ?pay_what_you_want: bool,
          ?suggested_price: Integer?,
          ?tax_inclusive: bool?
        ) -> void

        def to_hash: -> {
          currency: Dodopayments::Models::currency,
          discount: Integer,
          price: Integer,
          purchasing_power_parity: bool,
          type: Dodopayments::Models::Price::OneTimePrice::type_,
          pay_what_you_want: bool,
          suggested_price: Integer?,
          tax_inclusive: bool?
        }

        type type_ = :one_time_price

        module Type
          extend Dodopayments::Internal::Type::Enum

          ONE_TIME_PRICE: :one_time_price

          def self?.values: -> ::Array[Dodopayments::Models::Price::OneTimePrice::type_]
        end
      end

      type recurring_price =
        {
          currency: Dodopayments::Models::currency,
          discount: Integer,
          payment_frequency_count: Integer,
          payment_frequency_interval: Dodopayments::Models::time_interval,
          price: Integer,
          purchasing_power_parity: bool,
          subscription_period_count: Integer,
          subscription_period_interval: Dodopayments::Models::time_interval,
          type: Dodopayments::Models::Price::RecurringPrice::type_,
          tax_inclusive: bool?,
          trial_period_days: Integer
        }

      class RecurringPrice < Dodopayments::Internal::Type::BaseModel
        attr_accessor currency: Dodopayments::Models::currency

        attr_accessor discount: Integer

        attr_accessor payment_frequency_count: Integer

        attr_accessor payment_frequency_interval: Dodopayments::Models::time_interval

        attr_accessor price: Integer

        attr_accessor purchasing_power_parity: bool

        attr_accessor subscription_period_count: Integer

        attr_accessor subscription_period_interval: Dodopayments::Models::time_interval

        attr_accessor type: Dodopayments::Models::Price::RecurringPrice::type_

        attr_accessor tax_inclusive: bool?

        attr_reader trial_period_days: Integer?

        def trial_period_days=: (Integer) -> Integer

        def initialize: (
          currency: Dodopayments::Models::currency,
          discount: Integer,
          payment_frequency_count: Integer,
          payment_frequency_interval: Dodopayments::Models::time_interval,
          price: Integer,
          purchasing_power_parity: bool,
          subscription_period_count: Integer,
          subscription_period_interval: Dodopayments::Models::time_interval,
          type: Dodopayments::Models::Price::RecurringPrice::type_,
          ?tax_inclusive: bool?,
          ?trial_period_days: Integer
        ) -> void

        def to_hash: -> {
          currency: Dodopayments::Models::currency,
          discount: Integer,
          payment_frequency_count: Integer,
          payment_frequency_interval: Dodopayments::Models::time_interval,
          price: Integer,
          purchasing_power_parity: bool,
          subscription_period_count: Integer,
          subscription_period_interval: Dodopayments::Models::time_interval,
          type: Dodopayments::Models::Price::RecurringPrice::type_,
          tax_inclusive: bool?,
          trial_period_days: Integer
        }

        type type_ = :recurring_price

        module Type
          extend Dodopayments::Internal::Type::Enum

          RECURRING_PRICE: :recurring_price

          def self?.values: -> ::Array[Dodopayments::Models::Price::RecurringPrice::type_]
        end
      end

      type usage_based_price =
        {
          currency: Dodopayments::Models::currency,
          discount: Integer,
          fixed_price: Integer,
          payment_frequency_count: Integer,
          payment_frequency_interval: Dodopayments::Models::time_interval,
          purchasing_power_parity: bool,
          subscription_period_count: Integer,
          subscription_period_interval: Dodopayments::Models::time_interval,
          type: Dodopayments::Models::Price::UsageBasedPrice::type_,
          meters: ::Array[Dodopayments::AddMeterToPrice]?,
          tax_inclusive: bool?
        }

      class UsageBasedPrice < Dodopayments::Internal::Type::BaseModel
        attr_accessor currency: Dodopayments::Models::currency

        attr_accessor discount: Integer

        attr_accessor fixed_price: Integer

        attr_accessor payment_frequency_count: Integer

        attr_accessor payment_frequency_interval: Dodopayments::Models::time_interval

        attr_accessor purchasing_power_parity: bool

        attr_accessor subscription_period_count: Integer

        attr_accessor subscription_period_interval: Dodopayments::Models::time_interval

        attr_accessor type: Dodopayments::Models::Price::UsageBasedPrice::type_

        attr_accessor meters: ::Array[Dodopayments::AddMeterToPrice]?

        attr_accessor tax_inclusive: bool?

        def initialize: (
          currency: Dodopayments::Models::currency,
          discount: Integer,
          fixed_price: Integer,
          payment_frequency_count: Integer,
          payment_frequency_interval: Dodopayments::Models::time_interval,
          purchasing_power_parity: bool,
          subscription_period_count: Integer,
          subscription_period_interval: Dodopayments::Models::time_interval,
          type: Dodopayments::Models::Price::UsageBasedPrice::type_,
          ?meters: ::Array[Dodopayments::AddMeterToPrice]?,
          ?tax_inclusive: bool?
        ) -> void

        def to_hash: -> {
          currency: Dodopayments::Models::currency,
          discount: Integer,
          fixed_price: Integer,
          payment_frequency_count: Integer,
          payment_frequency_interval: Dodopayments::Models::time_interval,
          purchasing_power_parity: bool,
          subscription_period_count: Integer,
          subscription_period_interval: Dodopayments::Models::time_interval,
          type: Dodopayments::Models::Price::UsageBasedPrice::type_,
          meters: ::Array[Dodopayments::AddMeterToPrice]?,
          tax_inclusive: bool?
        }

        type type_ = :usage_based_price

        module Type
          extend Dodopayments::Internal::Type::Enum

          USAGE_BASED_PRICE: :usage_based_price

          def self?.values: -> ::Array[Dodopayments::Models::Price::UsageBasedPrice::type_]
        end
      end

      def self?.variants: -> ::Array[Dodopayments::Models::price]
    end
  end
end
